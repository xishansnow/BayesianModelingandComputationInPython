
<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>第五章: 样条 — Bayesian Modeling and Computation in Python</title>
<link href="../_static/css/theme.css" rel="stylesheet"/>
<link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet"/>
<link href="../_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
<link as="font" crossorigin="" href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css">
<link href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" rel="stylesheet" type="text/css">
<link href="../_static/togglebutton.css" rel="stylesheet" type="text/css">
<link href="../_static/copybutton.css" rel="stylesheet" type="text/css">
<link href="../_static/mystnb.css" rel="stylesheet" type="text/css">
<link href="../_static/sphinx-thebe.css" rel="stylesheet" type="text/css"/>
<link href="../_static/sphinx-codeautolink.css" rel="stylesheet" type="text/css"/>
<link href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" rel="stylesheet" type="text/css"/>
<link href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" rel="stylesheet" type="text/css"/>
<link as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js" rel="preload"/>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
<script src="../_static/jquery.js"></script>
<script src="../_static/underscore.js"></script>
<script src="../_static/doctools.js"></script>
<script src="../_static/togglebutton.js"></script>
<script src="../_static/clipboard.min.js"></script>
<script src="../_static/copybutton.js"></script>
<script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
<script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
<script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
<script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
<script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
<script async="async" src="../_static/sphinx-thebe.js"></script>
<link href="../_static/favicon.ico" rel="shortcut icon">
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="chp_06.html" rel="next" title="第六章: 时间序列"/>
<link href="chp_04.html" rel="prev" title="第四章：扩展线性模型"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="None" name="docsearch:language"/>
<!-- Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-702QMHG8ST"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-702QMHG8ST');
                </script>
</link></link></link></link></link></link></head>
<body data-offset="80" data-spy="scroll" data-target="#bd-toc-nav">
<div class="container-fluid" id="banner"></div>
<div class="container-xl">
<div class="row">
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
<div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
<h1 class="site-logo" id="site-title">Bayesian Modeling and Computation in Python</h1>
</a>
</div><form action="../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="icon fas fa-search"></i>
<input aria-label="Search this book..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search this book..." type="search"/>
</form><nav aria-label="Main" class="bd-links" id="bd-docs-nav">
<div class="bd-toc-item active">
<ul class="current nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="dedication.html">
   贡献
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="foreword.html">
   序言
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="preface.html">
   前言
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="symbollist.html">
   符号表
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_01.html">
   第一章: 贝叶斯推断
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_02.html">
   第二章: 贝叶斯模型的探索性分析
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_03.html">
   第三章：线性模型与概率编程语言
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_04.html">
   第四章：扩展线性模型
  </a>
</li>
<li class="toctree-l1 current active">
<a class="current reference internal" href="#">
   第五章: 样条
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_06.html">
   第六章: 时间序列
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_07.html">
   第七章：贝叶斯加性回归树
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_08.html">
   第八章：近似贝叶斯计算
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_09.html">
   第九章: 端到端的贝叶斯工作流
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_10.html">
   第十章: 概率编程语言
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="chp_11.html">
   第十一章: 附加主题
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="glossary.html">
   词汇表
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="references.html">
   References
  </a>
</li>
</ul>
</div>
</nav> <!-- To handle the deprecated key -->
<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>
</div>
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
<div class="topbar container-xl fixed-top">
<div class="topbar-contents row">
<div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
<div class="col pl-md-4 topbar-main">
<button aria-controls="site-navigation" aria-expanded="true" aria-label="Toggle navigation" class="navbar-toggler ml-0" data-placement="left" data-target=".site-navigation" data-toggle="tooltip" id="navbar-toggler" title="Toggle navigation" type="button">
<i class="fas fa-bars"></i>
<i class="fas fa-arrow-left"></i>
<i class="fas fa-arrow-up"></i>
</button>
<!-- Source interaction buttons -->
<div class="dropdown-buttons-trigger">
<button aria-label="Connect with source repository" class="btn btn-secondary topbarbtn" id="dropdown-buttons-trigger"><i class="fab fa-github"></i></button>
<div class="dropdown-buttons sourcebuttons">
<a class="repository-button" href="https://github.com/BayesianModelingandComputationInPython/BookCode_Edition1"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Source repository" type="button"><i class="fab fa-github"></i>repository</button></a>
<a class="issues-button" href="https://github.com/BayesianModelingandComputationInPython/BookCode_Edition1/issues/new?title=Issue%20on%20page%20%2Fzh_CN/chp_05.html&amp;body=Your%20issue%20content%20here."><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Open an issue" type="button"><i class="fas fa-lightbulb"></i>open issue</button></a>
</div>
</div>
<!-- Full screen (wrap in <a> to have style consistency -->
<a class="full-screen-button"><button aria-label="Fullscreen mode" class="btn btn-secondary topbarbtn" data-placement="bottom" data-toggle="tooltip" onclick="toggleFullScreen()" title="Fullscreen mode" type="button"><i class="fas fa-expand"></i></button></a>
<!-- Launch buttons -->
</div>
<!-- Table of contents -->
<div class="d-none d-md-block col-md-2 bd-toc show noprint">
<div class="tocsection onthispage pt-5 pb-3">
<i class="fas fa-list"></i> Contents
            </div>
<nav aria-label="Page" id="bd-toc-nav">
<ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#polynomial-regression">
   5.1 多项式回归
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#expanding-feature-space">
   5.2 扩展特征空间
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#introducing-splines">
   5.3 样条的基本原理
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#id12">
     5.3.1 基样条
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#de">
     5.3.2 用基样条构造复杂样条de
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#patsy">
   5.4 使用
   <code class="docutils literal notranslate">
<span class="pre">
     Patsy
    </span>
</code>
   软件包构建设计矩阵
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#pymc3">
   5.5 在 PYMC3 中拟合样条
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#choosing-knots-and-prior-for-splines">
   5.6 选择样条的结点和先验
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#id19">
     5.6.1 样条结点的选择
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#regularizing-prior-for-splines">
     5.6.2 样条的正则化先验
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#co-2">
   5.7 用样条对
   <span class="math notranslate nohighlight">
    \(CO_2\)
   </span>
   吸收量建模
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#exercises5">
   5.8 练习
  </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="row" id="main-content">
<div class="col-12 col-md-9 pl-md-3 pr-md-0">
<!-- Table of contents that is only displayed when printing the page -->
<div class="onlyprint" id="jb-print-docs-body">
<h1>第五章: 样条</h1>
<!-- Table of contents -->
<div id="print-main-content">
<div id="jb-print-toc">
<div>
<h2> Contents </h2>
</div>
<nav aria-label="Page">
<ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#polynomial-regression">
   5.1 多项式回归
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#expanding-feature-space">
   5.2 扩展特征空间
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#introducing-splines">
   5.3 样条的基本原理
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#id12">
     5.3.1 基样条
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#de">
     5.3.2 用基样条构造复杂样条de
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#patsy">
   5.4 使用
   <code class="docutils literal notranslate">
<span class="pre">
     Patsy
    </span>
</code>
   软件包构建设计矩阵
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#pymc3">
   5.5 在 PYMC3 中拟合样条
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#choosing-knots-and-prior-for-splines">
   5.6 选择样条的结点和先验
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#id19">
     5.6.1 样条结点的选择
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#regularizing-prior-for-splines">
     5.6.2 样条的正则化先验
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#co-2">
   5.7 用样条对
   <span class="math notranslate nohighlight">
    \(CO_2\)
   </span>
   吸收量建模
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#exercises5">
   5.8 练习
  </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div>
<div class="tex2jax_ignore mathjax_ignore section" id="chap3-5">
<span id="id1"></span><h1>第五章: 样条<a class="headerlink" href="#chap3-5" title="Permalink to this headline">¶</a></h1>
<style>p{text-indent:2em;2}</style>
<p>在本章中，我们将讨论样条曲线，它是 <a class="reference internal" href="chp_03.html#chap2"><span class="std std-ref">第 3 章</span></a> 中概念的延伸，旨在增加更多的灵活性。在<a class="reference internal" href="chp_03.html#chap2"><span class="std std-ref">第 3 章</span></a> 中介绍的模型中，结果变量和预测变量之间的关系在整个定义域中是相同的。相比之下，样条可以将一个问题分解为多个局部的解决方案，所有这些局部解可以组合起来生成一个有用的全局解决方案。</p>
<div class="section" id="polynomial-regression">
<span id="id2"></span><h2>5.1 多项式回归<a class="headerlink" href="#polynomial-regression" title="Permalink to this headline">¶</a></h2>
<p>正如在 <a class="reference internal" href="chp_03.html#chap2"><span class="std std-ref">第 3 章</span></a> 中所述，可以将线性模型写为：</p>
<div class="math notranslate nohighlight" id="equation-eq-lin-model">
<span class="eqno">(41)<a class="headerlink" href="#equation-eq-lin-model" title="Permalink to this equation">¶</a></span>\[\mathbb{E}[Y]= \beta_0 + \beta_1 X\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\beta_0\)</span> 是截距，<span class="math notranslate nohighlight">\(\beta_1\)</span> 是斜率，<span class="math notranslate nohighlight">\(\mathbb{E}[Y]\)</span> 是结果变量 <span class="math notranslate nohighlight">\(Y\)</span> 的期望（或均值）。可以将公式 <a class="reference internal" href="#equation-eq-lin-model">(41)</a> 扩展为如下形式：</p>
<div class="math notranslate nohighlight" id="equation-eq-polynomial-reg">
<span class="eqno">(42)<a class="headerlink" href="#equation-eq-polynomial-reg" title="Permalink to this equation">¶</a></span>\[\mathbb{E}[Y]= \beta_0 + \beta_1 X + \beta_2 X^2 + \cdots + \beta_m X^m\]</div>
<p>上式被称为多项式回归。</p>
<p>乍一看，公式 <a class="reference internal" href="#equation-eq-polynomial-reg">(42)</a> 似乎表示预测变量 <span class="math notranslate nohighlight">\(X、X^2 \cdots 、X^m\)</span> 的多元线性回归。从某种意义上说这也没有错，但关键是所有预测变量 <span class="math notranslate nohighlight">\(X^m\)</span> 都是由 <span class="math notranslate nohighlight">\(X\)</span> 的 <span class="math notranslate nohighlight">\(1\)</span> 到 <span class="math notranslate nohighlight">\(m\)</span> 次整数幂派生而来。因此，就实际问题而言，我们仍然在拟合一元预测变量。</p>
<p>我们称 <span class="math notranslate nohighlight">\(m\)</span> 为多项式的度。<a class="reference internal" href="chp_03.html#chap2"><span class="std std-ref">第 3 章</span></a> 和 <a class="reference internal" href="chp_04.html#chap3"><span class="std std-ref">第 4 章</span></a> 的线性回归模型都采用 <span class="math notranslate nohighlight">\(1\)</span> 次多项式。唯一的例外是 <a class="reference internal" href="chp_04.html#transforming-covariates"><span class="std std-ref">4.1 转换预测变量</span></a> 中的变方差模型，其中使用了 <span class="math notranslate nohighlight">\(m=1/2\)</span>。</p>
<p><a class="reference internal" href="#fig-polynomial-regression"><span class="std std-numref">Fig. 87</span></a> 显示了 <span class="math notranslate nohighlight">\(3\)</span> 个分别使用度为 <span class="math notranslate nohighlight">\(2\)</span>、<span class="math notranslate nohighlight">\(10\)</span> 和 <span class="math notranslate nohighlight">\(15\)</span> 的多项式回归示例。随着多项式阶数的增加，我们会得到更灵活的曲线。</p>
<div class="figure align-default" id="fig-polynomial-regression">
<a class="reference internal image-reference" href="../_images/polynomial_regression.png"><img alt="../_images/polynomial_regression.png" src="../_images/polynomial_regression.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 87 </span><span class="caption-text">度为 <span class="math notranslate nohighlight">\(2\)</span>、<span class="math notranslate nohighlight">\(10\)</span> 和 <span class="math notranslate nohighlight">\(15\)</span> 的多项式回归示例。随着度的增加，拟合变得更加扭曲。虚线是删除用蓝色十字表示的观测点后的拟合。当多项式的度为 <span class="math notranslate nohighlight">\(2\)</span> 或 <span class="math notranslate nohighlight">\(10\)</span> 时，删除数据点的影响较小，但在度为 <span class="math notranslate nohighlight">\(15\)</span> 时产生的影响比较明显。使用最小二乘法计算拟合。</span><a class="headerlink" href="#fig-polynomial-regression" title="Permalink to this image">¶</a></p>
</div>
<p>多项式的缺陷之一是其全局性，当我们应用一个度为 <span class="math notranslate nohighlight">\(m\)</span> 的多项式时，其实是在说：“预测变量和结果变量之间的关系对于 <em>整个数据集</em> 而言的度是 <span class="math notranslate nohighlight">\(m\)</span> ”。当数据的不同区域需要不同级别的灵活性时，这会出现问题，比如在某些区域导致曲线过于灵活 <a class="footnote-reference brackets" href="#id25" id="id3">1</a>。在 <a class="reference internal" href="#fig-polynomial-regression"><span class="std std-numref">Fig. 87</span></a>  的最后一个度为 <span class="math notranslate nohighlight">\(15\)</span> 子图中，可以看到，在 <span class="math notranslate nohighlight">\(X\)</span> 值增大的过程中，拟合曲线呈现出一个深谷，然后是一个高峰，即便不存在相应的真实观测点。</p>
<p>此外，随着度数增加，拟合变得更倾向于那些被删除的点，或者等效于添加了若干未来数据；换句话说，随着度数的增加，模型变得比较容易过拟合。例如，在 <a class="reference internal" href="#fig-polynomial-regression"><span class="std std-numref">Fig. 87</span></a> 中，黑线表示对整个数据集的拟合，虚线表示删除一个数据点（图中用叉号表示）后的拟合。可以看到，尤其是在最后一个子图中，即使删除单个数据点也会改变模型的拟合结果，这种效应甚至延伸至了远离该点的位置。</p>
</div>
<div class="section" id="expanding-feature-space">
<span id="id4"></span><h2>5.2 扩展特征空间<a class="headerlink" href="#expanding-feature-space" title="Permalink to this headline">¶</a></h2>
<p>在概念层面上，我们可以将多项式回归视为一种创建新预测变量的方法，或者表述为更正式的术语：<strong>对特征空间进行了扩展</strong>。通过执行特征扩展，我们在扩展空间中拟合的一条直线，可能代表原始数据空间中的一条曲线，非常简洁！但特征扩展并不能随意使用，我们不能总是期望通过随意地对数据使用变换，就能得到我们享有的好结果。</p>
<p>为了概括特征扩展的概念，可以将公式 <a class="reference internal" href="#equation-eq-lin-model">(41)</a> 进一步扩展为以下形式：</p>
<div class="math notranslate nohighlight" id="equation-eq-bfr">
<span class="eqno">(43)<a class="headerlink" href="#equation-eq-bfr" title="Permalink to this equation">¶</a></span>\[\mathbb{E}[Y]= \beta_0 + \beta_1 B_{1}(X_{1}) + \beta_2 B_{2}(X_{2}) + \cdots + \beta_m B_{m}(X_{m})\]</div>
<p>其中 <span class="math notranslate nohighlight">\(B_i\)</span> 是任意函数，我们称之为基函数。基函数的线性组合构造出一个函数 <span class="math notranslate nohighlight">\(f\)</span>，它才是真正拟合的模型。从这个意义上说，<span class="math notranslate nohighlight">\(B_i\)</span> 是构建灵活函数 <span class="math notranslate nohighlight">\(f\)</span> 的幕后君子。</p>
<div class="math notranslate nohighlight" id="equation-eq-bfr2">
<span class="eqno">(44)<a class="headerlink" href="#equation-eq-bfr2" title="Permalink to this equation">¶</a></span>\[\mathbb{E}[Y]= \sum_i^m \beta_i B_{i}(X_{i}) = f(X) \]</div>
<p>基函数 <span class="math notranslate nohighlight">\(B_i\)</span> 有很多选择，多项式是其中之一，也可以应用任意一组函数，例如 <span class="math notranslate nohighlight">\(2\)</span> 的幂、对数、平方根等。选择哪个函数通常是由待解决的问题驱动的，例如，在第 <a class="reference internal" href="chp_04.html#transforming-covariates"><span class="std std-ref">4.1 转换预测变量</span></a> 节中，我们通过平方根来模拟婴儿的身高随年龄变化的函数，其动机是人类婴儿在生命早期阶段生长得更快，然后趋于平稳，和平方根函数的效果很接近。</p>
<p>另一种替代方法是使用 <span class="math notranslate nohighlight">\(I(c_i \leq x_k &lt; c_j)\)</span> 之类的指示函数，将原始 <span class="math notranslate nohighlight">\(\boldsymbol{X}\)</span> 预测变量分解为若干个（非重叠的）子集。然后在这些子集内分别拟合局部的多项式。此过程导致拟合出 <strong>分段多项式</strong> <a class="footnote-reference brackets" href="#id26" id="id5">2</a>，如 <a class="reference internal" href="#fig-piecewise"><span class="std std-numref">Fig. 88</span></a> 所示。</p>
<div class="figure align-default" id="fig-piecewise">
<a class="reference internal image-reference" href="../_images/piecewise.png"><img alt="../_images/piecewise.png" src="../_images/piecewise.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 88 </span><span class="caption-text">蓝线是我们试图逼近的 <em>真实</em> 函数。黑色实线是递增阶数（<span class="math notranslate nohighlight">\(1\)</span>、<span class="math notranslate nohighlight">\(2\)</span>、<span class="math notranslate nohighlight">\(3\)</span> 和 <span class="math notranslate nohighlight">\(4\)</span>）的分段多项式。在 <span class="math notranslate nohighlight">\(x\)</span> 轴上垂直的灰色虚线标记每个子域的约束边界。</span><a class="headerlink" href="#fig-piecewise" title="Permalink to this image">¶</a></p>
</div>
<p><a class="reference internal" href="#fig-piecewise"><span class="std std-numref">Fig. 88</span></a> 的四个子图目标相同，用于近似蓝色曲线对应的函数。我们首先将函数分成 <span class="math notranslate nohighlight">\(3\)</span> 个子域，由灰色虚线分隔，然后为每个子域拟合不同的函数。</p>
<p>在第一个子图（ 分段常数 ）中，我们拟合了一个常数函数，可以将其视为零次多项式。聚合的解决方案，即黑色的 3 条线段被称为 <strong>阶梯函数（ step-function ）</strong>。这似乎是一个相当粗略的近似值，但它可能就是我们所需要的。举个例子，如果我们想找出早上、下午和晚上的预期平均温度，则阶跃函数就可以解决问题。</p>
<p>在第二个子图（分段线性）中，我们执行与第一个子图相同的操作，但使用线性函数而不是常数，即它是一次多项式。请注意，相邻的两个线性解决方案在虚线处相遇，这是故意完成的。这种限制是为了使解决方案尽可能的平滑<a class="footnote-reference brackets" href="#id27" id="id6">4</a>。</p>
<p>在第三个子图（分段二次）和第四个子图（分段三次）中，我们使用二次和三次分段多项式。通过增加分段多项式的次数，可以得到越来越灵活的解决方案，这在带来了更好的拟合同时，也带来了更高的过拟合风险。</p>
<p>因为最终拟合是由局部解（<span class="math notranslate nohighlight">\(B_i\)</span> 基函数）构造的函数 <span class="math notranslate nohighlight">\(f\)</span>，我们可以更轻松地适应模型的灵活性以适应不同区域的数据需求。在这种特殊情况下，我们可以使用更简单的函数（阶数较低的多项式）来拟合不同区域的数据，同时提供适合整个数据域的良好整体模型。</p>
<p>到目前为止，我们假设仅有一个预测变量 <span class="math notranslate nohighlight">\(X\)</span>，但同样的想法可以扩展到多个预测变量 <span class="math notranslate nohighlight">\(X_0, X_1, \cdots, X_p\)</span> ( 注意：<span class="math notranslate nohighlight">\(X_i\)</span> 之间相互独立，见公式 )。在此基础上，我们甚至可以添加一个反向链接函数 <span class="math notranslate nohighlight">\(\phi\)</span> ，而这种形式的模型被称为广义可加模型 (GAM) <a class="footnote-reference brackets" href="#id28" id="id7">5</a> ，参见 <span id="id8">[<a class="reference internal" href="references.html#id3">18</a>, <a class="reference internal" href="references.html#id4">49</a>]</span>。</p>
<div class="math notranslate nohighlight" id="equation-eq-gam">
<span class="eqno">(45)<a class="headerlink" href="#equation-eq-gam" title="Permalink to this equation">¶</a></span>\[\mathbb{E}[Y]= \phi \left(\sum_i^p f(X_i)\right) \]</div>
<p>概括一下在本节中学到的知识，公式 <a class="reference internal" href="#equation-eq-bfr">(43)</a> 中的 <span class="math notranslate nohighlight">\(B_i\)</span> 函数是一种巧妙的统计工具，它允许我们拟合更灵活的模型。原则上，可以自由选择任意 <span class="math notranslate nohighlight">\(B_i\)</span> 函数，根据领域知识做探索性数据分析，并形成阶段性结果，甚至可以通过反复试验来选择 <span class="math notranslate nohighlight">\(B_i\)</span> 。并非所有转换都具有相同的统计属性，因此最好能够在更广泛的数据集上评估一些具有良好通用属性的默认函数。从下一节开始，本书将讨论限制在被称为 <code class="docutils literal notranslate"><span class="pre">基样条</span></code> 的基函数族 <a class="footnote-reference brackets" href="#id29" id="id9">6</a> 。</p>
</div>
<div class="section" id="introducing-splines">
<span id="id10"></span><h2>5.3 样条的基本原理<a class="headerlink" href="#introducing-splines" title="Permalink to this headline">¶</a></h2>
<p>样条曲线是一种试图利用多项式的灵活性、同时又能控制其缺点的、具有整体良好统计特性的模型。要定义样条曲线，首先要定义样条中的结点（ Knots ） <a class="footnote-reference brackets" href="#id30" id="id11">7</a>。结点的作用是将变量 <span class="math notranslate nohighlight">\(\boldsymbol{X}\)</span> 的域分割成连续区间。例如，<a class="reference internal" href="#fig-piecewise"><span class="std std-numref">Fig. 88</span></a> 中的灰色垂直虚线就表示结点。</p>
<p>为了达到既具备灵活性，又能控制多项式缺陷的目的，样条曲线被设计为一个连续的分段多项式。也就是说，强制要求两个连续区间的子多项式在结点处也能保持连续。如果子多项式的度数 ( Degree ) 为 <span class="math notranslate nohighlight">\(n\)</span>，则称该样条曲线的度数为 <span class="math notranslate nohighlight">\(n\)</span>。有时也用样条曲线的阶数（ Order ，增加一项幂为 <span class="math notranslate nohighlight">\(0\)</span> 的常数项）来表示，即相同情况下，阶数为度数加 <span class="math notranslate nohighlight">\(1\)</span> 。</p>
<p>在 <a class="reference internal" href="#fig-piecewise"><span class="std std-numref">Fig. 88</span></a> 中，可以看到随着分段多项式阶数增加，结果函数的 <em>平滑度</em> 也会增加。正如已经提到的，子多项式应该在结点处保持连续。在第一个子图上，我们似乎在作弊，因为相邻区间之间存在阶梯，并不连续。但如果限制条件是在每个区间使用常数，那么这可能是最好的结果了。</p>
<div class="section" id="id12">
<h3>5.3.1 基样条<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>在谈论样条时，子多项式被形式化地称为<strong>基样条或简称 <code class="docutils literal notranslate"><span class="pre">B-样条</span></code></strong> ，<strong>任意指定度数（或阶数）的样条，都可以被构造为若干具有相同度数（或阶数）基样条的线性组合。</strong></p>
<p><a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a> 显示了从 <span class="math notranslate nohighlight">\(0\)</span> 度到 <span class="math notranslate nohighlight">\(3\)</span> 度（从上到下）递增的基样条示例，底部的点代表样条中的结点，其中蓝色点表示基样条 (黑色实线）值不为 <span class="math notranslate nohighlight">\(0\)</span> 的结点（即该基样条的作用域）。图中也标出了相同度数下的其他基样条，均使用不同颜色较细的虚线来区分。事实上，<a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a> 中的四个子图都显示了由指定结点定义的所有基样条。也就是说，基样条完全由一组结点和度数定义。</p>
<div class="figure align-default" id="fig-splines-basis">
<a class="reference internal image-reference" href="../_images/splines_basis.png"><img alt="../_images/splines_basis.png" src="../_images/splines_basis.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 89 </span><span class="caption-text">度数逐步增加的基样条，从 <span class="math notranslate nohighlight">\(0\)</span> 度到 <span class="math notranslate nohighlight">\(3\)</span> 度。顶部子图为一个阶梯状的函数，第二个子图为一个三角状的函数，然后是越来越多高斯状的函数。图中在边界处添加了堆叠结点（用较小黑点表示），以便在边界附近有足够数量的结点来构建基样条。</span><a class="headerlink" href="#fig-splines-basis" title="Permalink to this image">¶</a></p>
</div>
<p>从 <a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a> 中可以看到，随着基样条度数的增加，基样条的域跨度也越来越大 <a class="footnote-reference brackets" href="#id31" id="id13">8</a>。为了使更高度数的样条有意义，也就需要定义更多结点。需要注意的是：在所有情况下，基样条仅在给定区间内取值非 <span class="math notranslate nohighlight">\(0\)</span>，而在区间外均取值为 <span class="math notranslate nohighlight">\(0\)</span>。此属性使样条回归比多项式回归更具备 <em>局部性</em> 。</p>
<p>用于构造每个基样条的结点数，也会随着度数增加而增长。这就造成一种边界效应，即对于所有大于 <span class="math notranslate nohighlight">\(0\)</span> 的度数，在边界附近会出现无法定义基样条的现象。因为在边界处的基样条较少，所以样条函数会在边界处受到影响。好在此边界问题很容易解决，只需在边界处复制足够数量的结点即可（参见 <a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a> 中的小黑点）。举例来说，如果样条的结点集合为 <span class="math notranslate nohighlight">\(\{0,1,2,3,4,5\}\)</span> ，现在想要拟合一个三次样条曲线（ 即 <a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a> 的最后一个子图中 ），那么为解决边界效应问题，我们实际使用的节点集合应当为 <span class="math notranslate nohighlight">\(\{0,0,0,0,1,2,3,4,5,5,5,5\}\)</span> 。也就是说，在起点填充了 <span class="math notranslate nohighlight">\(3\)</span> 次结点 <span class="math notranslate nohighlight">\(0\)</span> ，在终点填充了 <span class="math notranslate nohighlight">\(3\)</span> 次结点 <span class="math notranslate nohighlight">\(5\)</span>。通过这种方法，就可以有五个必要结点 <span class="math notranslate nohighlight">\(\{0,0,0,0,1\}\)</span> 来定义第一个基样条（ <a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a>  最后一个子图中类似指数分布的靛蓝色虚线 )；然后使用结点 <span class="math notranslate nohighlight">\(\{0,0,0,1,2\}\)</span> 来定义第二个基样条（ 类似 <code class="docutils literal notranslate"><span class="pre">Beta</span> <span class="pre">分布</span></code>的那条曲线 ），以此类推。请读者注意观察由结点集合 <span class="math notranslate nohighlight">\(\{0,1,2,3,4\}\)</span> 定义的第一个非堆叠的、完整的基样条（ 黑色实线 ）。在边界处需要填充的结点数，应当与样条的度数保持一致，因此 <span class="math notranslate nohighlight">\(0\)</span> 度样条无需对堆叠结点，而 <span class="math notranslate nohighlight">\(3\)</span> 度样条需要在头尾共堆叠 <span class="math notranslate nohighlight">\(6\)</span> 个结点。</p>
</div>
<div class="section" id="de">
<h3>5.3.2 用基样条构造复杂样条de<a class="headerlink" href="#de" title="Permalink to this headline">¶</a></h3>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 软件包定义的基样条。在第一行中可以看到以灰色虚线表示的 <span class="math notranslate nohighlight">\(1\)</span> 阶（分段常数）、<span class="math notranslate nohighlight">\(2\)</span> 阶（分段线性）和 <span class="math notranslate nohighlight">\(4\)</span> 阶（分段三次）样条曲线。为了清楚起见，每个基样条都用不同的颜色表示。在第二行中，将第一行的基样条按一组系数加权，粗黑线表示了这些基样条的加权和。需要注意的是，图中的系数值是随机生成的，因此第二行中每个图中的粗黑线，都只能被视为 <em>样条空间</em> 中的一个随机样本。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
在这个例子中，我们从半高斯分布（代码 [splines_patsy_plot](splines_patsy_plot) 中的第 $17$ 行）中采样生成 $\beta_i$ 系数。因此，{numref}`fig:splines_weighted` 中的每个子图仅显示了样条空间中的一种实现。你可以删除随机种子，然后多运行代码 [splines_patsy_plot](splines_patsy_plot) 几次，每次你都会看到不同的样条曲线。此外，你还可以尝试将半高斯分布替换为高斯分布、指数分布等其他分布。{numref}`fig:splines_realizations` 中显示了三次样条的四种可能的实现。

```{figure} figures/splines_realizations.png
:name: fig:splines_realizations
:width: 8.00in

从半高斯分布中采样得到 $\beta_i$ 系数的四种三次样条实现。

</pre></div>
</div>
<div class="admonition- admonition">
<p class="admonition-title">三次样条（或四阶样条）是样条中的王者</p>
<p>在所有可能的样条中，三次样条是最常用的。但为什么三次样条曲线是样条曲线的王者呢？图 <a class="reference internal" href="#fig-piecewise"><span class="std std-numref">Fig. 88</span></a> 和 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 提供了一些提示。三次样条曲线为我们提供了能够为大多数场景生成 <em>足够平滑</em> 曲线所需的最低阶样条曲线，从而降低了更高阶样条曲线对人们的吸引力。所谓 <em>足够平滑</em> 是什么意思？在不深入数学细节的情况下，其大致意思是拟合的函数不会出现斜率的突然变化。这样做的一种方法是添加两个连续的分段多项式应该在其公共结点处相遇的约束条件，而三次样条另外增加了两个约束：其在结点处的一阶和二阶导数都是连续的。这意味着斜率在结点处是连续的，并且斜率的斜率也连续 <a class="footnote-reference brackets" href="#id32" id="id14">9</a>。事实上，<span class="math notranslate nohighlight">\(m\)</span> 度的样条曲线在结点处会有 <span class="math notranslate nohighlight">\(m-1\)</span> 阶导数。尽管说了这么多，低阶或高阶样条对于某些特定问题还是有用的，只是三次样条是很好的默认值。</p>
</div>
</div>
</div>
<div class="section" id="patsy">
<span id="building-the-design-matrix-using-patsy"></span><h2>5.4 使用 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 软件包构建设计矩阵<a class="headerlink" href="#patsy" title="Permalink to this headline">¶</a></h2>
<p>在图 <a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a> 和 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 中，我们绘制了基样条线，但一直没有提到如何计算它们，主要原因是样条的计算很麻烦，并且在 <code class="docutils literal notranslate"><span class="pre">Scipy</span></code> <a class="footnote-reference brackets" href="#id33" id="id15">10</a> 等软件包中已经有有效的可用算法。因此，我们不打算从头开始计算基样条，而是依赖 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 软件包，这是一个用于描述统计模型（尤其是线性模型，或具有线性组件的模型）和构建设计矩阵的包。其灵感来自 R 编程语言生态系统的许多包中广泛使用的 <em>形式化迷你语言</em> 。例如，具有两个预测变量的线性模型看起来类似<code class="docutils literal notranslate"><span class="pre">"y</span> <span class="pre">~</span> <span class="pre">x1</span> <span class="pre">+</span> <span class="pre">x2"</span></code>，如果想添加交互，可以写成<code class="docutils literal notranslate"><span class="pre">"y</span> <span class="pre">~</span> <span class="pre">x1</span> <span class="pre">+</span> <span class="pre">x2</span> <span class="pre">+</span> <span class="pre">x1:x2"</span></code>。这与 <a class="reference internal" href="chp_03.html#chap2"><span class="std std-ref"> 第 3 章 </span></a> 中提到的 <code class="docutils literal notranslate"><span class="pre">Bambi</span></code> 语法有相似之处。有关详细信息，请查看 <code class="docutils literal notranslate"><span class="pre">patsy</span></code> 文档 <a class="footnote-reference brackets" href="#id34" id="id16">11</a>。</p>
<p>要在 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 中定义基样条设计矩阵，我们需要将以 <code class="docutils literal notranslate"><span class="pre">bs()</span></code> 开头的字符串 <em>粒子</em> 传递给 <code class="docutils literal notranslate"><span class="pre">dmatrix</span></code> 函数，该粒子是一个能够被 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 解析为函数的字符串。因此，它可以接受多个参数，包括数据、样条结点数组、样条的度数等。在代码 <a class="reference internal" href="#splines-patsy"><span class="std std-ref">splines_patsy</span></a> 中，我们定义了 <span class="math notranslate nohighlight">\(3\)</span> 个设计矩阵，第一个为 <span class="math notranslate nohighlight">\(0\)</span> 次样条（分段常数），第二个为 <span class="math notranslate nohighlight">\(1\)</span> 次样条（分段线性），最后一个为 <span class="math notranslate nohighlight">\(3\)</span> 次样条。</p>
<div class="literal-block-wrapper docutils container" id="splines-patsy">
<div class="code-block-caption"><span class="caption-number">Listing 62 </span><span class="caption-text">splines_patsy</span><a class="headerlink" href="#splines-patsy" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html#numpy.linspace" title="numpy.linspace"><span class="n">np</span><span class="o">.</span><span class="n">linspace</span></a><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="n">knots</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]</span>

<span class="n">B0</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="s2">"bs(x, knots=knots, degree=0, include_intercept=True) - 1"</span><span class="p">,</span> 
             <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span><span class="n">knots</span><span class="p">})</span>
<span class="n">B1</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="s2">"bs(x, knots=knots, degree=1, include_intercept=True) - 1"</span><span class="p">,</span>
             <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span><span class="n">knots</span><span class="p">})</span>
<span class="n">B3</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="s2">"bs(x, knots=knots, degree=3,include_intercept=True) - 1"</span><span class="p">,</span>
             <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span><span class="n">knots</span><span class="p">})</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#fig-design-matrices"><span class="std std-numref">Fig. 90</span></a> 表示使用代码 <a class="reference internal" href="#splines-patsy"><span class="std std-ref">splines_patsy</span></a> 计算的 <span class="math notranslate nohighlight">\(3\)</span> 个设计矩阵。为了更好地掌握 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 在做什么，建议你使用 Jupyter notebook/lab 或其他 IDE 来检查对象 <code class="docutils literal notranslate"><span class="pre">B0</span></code>、<code class="docutils literal notranslate"><span class="pre">B1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">B2</span></code>。</p>
<div class="figure align-default" id="fig-design-matrices">
<a class="reference internal image-reference" href="../_images/design_matrices.png"><img alt="../_images/design_matrices.png" src="../_images/design_matrices.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 90 </span><span class="caption-text">在代码 <a class="reference internal" href="#splines-patsy"><span class="std std-ref">splines_patsy</span></a> 中使用 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 生成的设计矩阵。颜色从黑色 ( <span class="math notranslate nohighlight">\(1\)</span> ) 变为浅灰色 ( <span class="math notranslate nohighlight">\(0\)</span> )，列数是基样条数，行数是数据点数。</span><a class="headerlink" href="#fig-design-matrices" title="Permalink to this image">¶</a></p>
</div>
<p><a class="reference internal" href="#fig-design-matrices"><span class="std std-numref">Fig. 90</span></a> 的第一个子图对应于 <code class="docutils literal notranslate"><span class="pre">B0</span></code>，一个 <span class="math notranslate nohighlight">\(0\)</span> 次样条曲线。对于前 <span class="math notranslate nohighlight">\(5\)</span> 个观测值，我们可以看到设计矩阵是一个只有 <span class="math notranslate nohighlight">\(0\)</span>（浅灰色）和 <span class="math notranslate nohighlight">\(1\)</span>（黑色）的矩阵。第一个基样条（第 <span class="math notranslate nohighlight">\(0\)</span> 列）为 <span class="math notranslate nohighlight">\(1\)</span>，否则为 <span class="math notranslate nohighlight">\(0\)</span>，对于前 <span class="math notranslate nohighlight">\(5\)</span> 个观测值，第二个基样条（第 <span class="math notranslate nohighlight">\(1\)</span> 列）为 <span class="math notranslate nohighlight">\(0\)</span>，对于后 <span class="math notranslate nohighlight">\(5\)</span> 个观测值为 <span class="math notranslate nohighlight">\(1\)</span>，再次为 <span class="math notranslate nohighlight">\(0\)</span>。并且重复相同的模式。将此与 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 的第一个子图（第一行）进行比较，你应该会看到设计矩阵如何编码该图。</p>
<p>对于 <a class="reference internal" href="#fig-design-matrices"><span class="std std-numref">Fig. 90</span></a> 中的第二个子图，我们有第一个基样条从 <span class="math notranslate nohighlight">\(1\)</span> 到 <span class="math notranslate nohighlight">\(0\)</span>，第二、第三和第四个基样条从 <span class="math notranslate nohighlight">\(0\)</span> 到 <span class="math notranslate nohighlight">\(1\)</span>，然后从 <span class="math notranslate nohighlight">\(1\)</span> 到 <span class="math notranslate nohighlight">\(0\)</span>。第五个基样条从 <span class="math notranslate nohighlight">\(0\)</span> 到 <span class="math notranslate nohighlight">\(1\)</span>。你可以在 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 的第二个子图（第一行）中看到与此模式匹配的一条负斜率的线、三个三角函数和一条正斜率的线。</p>
<p>最后，如果我们比较 <a class="reference internal" href="#fig-design-matrices"><span class="std std-numref">Fig. 90</span></a> 的第三个子图中的 <span class="math notranslate nohighlight">\(7\)</span> 个列与 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 的第三个子图（第一行）中的 <span class="math notranslate nohighlight">\(7\)</span> 条曲线，可以看到匹配的类似结果。</p>
<p>代码 <a class="reference internal" href="#splines-patsy"><span class="std std-ref">splines_patsy</span></a> 用于生成图 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 和 <a class="reference internal" href="#fig-design-matrices"><span class="std std-numref">Fig. 90</span></a> 中的基样条，唯一不同的是前者使用了 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">np</span> <span class="pre">.linspace(0.,</span> <span class="pre">1.,</span> <span class="pre">500)</span></code>，所以曲线看起来更平滑，而后者使用了 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">np.linspace(0.,</span> <span class="pre">1.,</span> <span class="pre">20)</span></code>，这样矩阵更容易理解。</p>
<div class="literal-block-wrapper docutils container" id="splines-patsy-plot">
<div class="code-block-caption"><span class="caption-number">Listing 63 </span><span class="caption-text">splines_patsy_plot</span><a class="headerlink" href="#splines-patsy-plot" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplots.html#matplotlib.pyplot.subplots" title="matplotlib.pyplot.subplots"><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span></a><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="s2">"row"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="n">B0</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">B3</span><span class="p">),</span>
                                     <span class="p">(</span><span class="s2">"Piecewise constant"</span><span class="p">,</span>
                                      <span class="s2">"Piecewise linear"</span><span class="p">,</span>
                                      <span class="s2">"Cubic spline"</span><span class="p">))):</span>
    <span class="c1"># plot spline basis functions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                          <span class="n">color</span><span class="o">=</span><span class="n">viridish</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">"--"</span><span class="p">)</span>
    <span class="c1"># we generate some positive random coefficients </span>
    <span class="c1"># there is nothing wrong with negative values</span>
    <span class="n">β</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.normal.html#numpy.random.normal" title="numpy.random.normal"><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span></a><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># plot spline basis functions scaled by its β</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">β</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                          <span class="n">color</span><span class="o">=</span><span class="n">viridish</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">"--"</span><span class="p">)</span>
    <span class="c1"># plot the sum of the basis functions</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/generated/numpy.dot.html#numpy.dot" title="numpy.dot"><span class="n">np</span><span class="o">.</span><span class="n">dot</span></a><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">β</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">"k"</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># plot the knots</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">knots</span><span class="p">,</span> <a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/generated/numpy.zeros_like.html#numpy.zeros_like" title="numpy.zeros_like"><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span></a><span class="p">(</span><span class="n">knots</span><span class="p">),</span> <span class="s2">"ko"</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">knots</span><span class="p">,</span> <a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/generated/numpy.zeros_like.html#numpy.zeros_like" title="numpy.zeros_like"><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span></a><span class="p">(</span><span class="n">knots</span><span class="p">),</span> <span class="s2">"ko"</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>到目前为止，我们已经探索了几个示例，以直观了解样条是什么以及如何在 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 的帮助下自动创建它们。下一步可以看一下如何对样条模型进行拟合，以获得权重参数的分布。</p>
</div>
<div class="section" id="pymc3">
<span id="fitting-splines-in-pymc3"></span><h2>5.5 在 PYMC3 中拟合样条<a class="headerlink" href="#pymc3" title="Permalink to this headline">¶</a></h2>
<p>在本节中，我们使用 PYMC3 来将一组基样条拟合到观测数据上，进而获得回归系数 <span class="math notranslate nohighlight">\(\beta\)</span> 的值。本节采用的例子是现代共享单车系统。</p>
<p>现代共享单车系统允许人们以完全自动化的方式租用和归还自行车，有助于提高公共交通的效率。我们将利用加州大学欧文分校机器学习库 <a class="footnote-reference brackets" href="#id35" id="id17">12</a> 的一个共享单车系统数据集，来估计 <span class="math notranslate nohighlight">\(24\)</span> 小时内每小时的自行车租用数量。</p>
<p>让我们加载并绘制数据：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">"../data/bikes_hour.csv"</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">"hour"</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># We standardize the response variable</span>
<span class="n">data_cnt_om</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">"count"</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">data_cnt_os</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">"count"</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="n">data</span><span class="p">[</span><span class="s2">"count_normalized"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">"count"</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_cnt_om</span><span class="p">)</span> <span class="o">/</span> <span class="n">data_cnt_os</span>
<span class="c1"># Remove data, you may later try to refit the model to the whole data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[::</span><span class="mi">50</span><span class="p">]</span>
</pre></div>
</div>
<div class="figure align-default" id="fig-bikes-data">
<a class="reference internal image-reference" href="../_images/bikes_data.png"><img alt="../_images/bikes_data.png" src="../_images/bikes_data.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 91 </span><span class="caption-text">自行车数据的可视化。每个点是一天中每小时的自行车租用标准化值（在区间 <span class="math notranslate nohighlight">\(0\)</span>、<span class="math notranslate nohighlight">\(23\)</span> 上）。这些点是半透明的，以避免点过度重叠，从而有助于查看数据的分布。</span><a class="headerlink" href="#fig-bikes-data" title="Permalink to this image">¶</a></p>
</div>
<p>快速查看 <a class="reference internal" href="#fig-bikes-data"><span class="std std-numref">Fig. 91</span></a> 会发现，一天中的时间与出租自行车数量之间的关系并不能通过拟合一条线来很好地捕捉到。因此，让我们尝试使用样条回归来更好地逼近非线性模式。</p>
<p>正如我们已经提到的，为了使用样条曲线，我们需要定义结点的数量和位置。我们将使用 6 个结点并使用最简单的选项来定位它们，每个结点之间的间距相等。</p>
<div class="literal-block-wrapper docutils container" id="knot-list">
<div class="code-block-caption"><span class="caption-number">Listing 64 </span><span class="caption-text">knot_list</span><a class="headerlink" href="#knot-list" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_knots</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">knot_list</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html#numpy.linspace" title="numpy.linspace"><span class="n">np</span><span class="o">.</span><span class="n">linspace</span></a><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="n">num_knots</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>请注意，在代码 <a class="reference internal" href="#knot-list"><span class="std std-ref">knot_list</span></a> 中，我们定义了 8 个结点，但随后我们删除了第一个和最后一个结点，确保保留在数据的 <em>interior</em> 中定义的 6 个结点。这是否是一个有用的策略将取决于数据。例如，如果大部分数据远离边界，这将是一个好主意，结点的数量越大，它们的位置就越不重要。</p>
<p>现在我们使用 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 为我们定义和构建设计矩阵：</p>
<div class="literal-block-wrapper docutils container" id="bikes-dmatrix">
<div class="code-block-caption"><span class="caption-number">Listing 65 </span><span class="caption-text">bikes_dmatrix</span><a class="headerlink" href="#bikes-dmatrix" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span>
    <span class="s2">"bs(cnt, knots=knots, degree=3, include_intercept=True) - 1"</span><span class="p">,</span>
    <span class="p">{</span><span class="s2">"cnt"</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">hour</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span> <span class="n">knot_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]})</span>
</pre></div>
</div>
</div>
<p>建议的统计模型是：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\begin{split}
  \tau \sim&amp; \; \mathcal{HC}(1) \\
  \boldsymbol{\beta} \sim&amp; \; \mathcal{N}(0, \tau) \\
  \sigma \sim&amp; \; \mathcal{HN}(1) \\
  Y \sim&amp; \; \mathcal{N}(\boldsymbol{B}(X)\boldsymbol{\beta},\sigma)
\end{split}\end{aligned}\end{split}\]</div>
<p>我们的样条回归模型与第  <a class="reference internal" href="chp_03.html#chap2"><span class="std std-ref">3</span></a> 章中的线性模型非常相似。所有的工作都是由设计矩阵 <span class="math notranslate nohighlight">\(\boldsymbol{B}\)</span> 及其对特征空间的扩展完成的。请注意，我们使用线性代数符号将公式 <a class="reference internal" href="#equation-eq-bfr">(43)</a> 和 <a class="reference internal" href="#equation-eq-bfr2">(44)</a> 的乘法和求和写成更短的形式，即我们写成 <span class="math notranslate nohighlight">\(\boldsymbol{\mu} = \boldsymbol{B}\boldsymbol{\beta}\)</span> 而不是 <span class="math notranslate nohighlight">\(\boldsymbol{\mu} = \sum_i^n B_i \boldsymbol{\beta}_i\)</span>。</p>
<p>像往常一样，统计语法以几乎一对一的方式翻译成 PyMC3。</p>
<div class="literal-block-wrapper docutils container" id="splines">
<div class="code-block-caption"><span class="caption-number">Listing 66 </span><span class="caption-text">splines</span><a class="headerlink" href="#splines" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">splines</span><span class="p">:</span>
    <span class="n">τ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s2">"τ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">β</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"β"</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="n">τ</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">μ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Deterministic</span><span class="p">(</span><span class="s2">"μ"</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">β</span><span class="p">))</span>
    <span class="n">σ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s2">"σ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"c"</span><span class="p">,</span> <span class="n">μ</span><span class="p">,</span> <span class="n">σ</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">"count_normalized"</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">idata_s</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">return_inferencedata</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>我们在 <a class="reference internal" href="#fig-bikes-spline-raw-data"><span class="std std-numref">Fig. 92</span></a> 中将最终拟合的线性预测显示为黑色实线，每个加权基样条显示为虚线。这是一个很好的表示，因为我们可以看到基样条如何影响最终结点果。</p>
<div class="figure align-default" id="fig-bikes-spline-raw-data">
<a class="reference internal image-reference" href="../_images/bikes_spline_raw_data.png"><img alt="../_images/bikes_spline_raw_data.png" src="../_images/bikes_spline_raw_data.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 92 </span><span class="caption-text">使用样条拟合的自行车数据。 B样条用虚线表示。它们的总和产生更粗的黑色实线。
绘制的值对应于后验的均值。黑点代表结点。相对于 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 中绘制的样条线，此图中的样条线看起来非常<em>锯齿状</em>。原因是我们在更少的点上评估函数。此处为 24 分，因为数据每小时分箱，而 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 中的数据为 500。</span><a class="headerlink" href="#fig-bikes-spline-raw-data" title="Permalink to this image">¶</a></p>
</div>
<p>当我们想要显示模型的结果时，更有用的绘图是使用重叠样条及其不确定性绘制数据，如 <a class="reference internal" href="#fig-bikes-data2"><span class="std std-numref">Fig. 93</span></a>。从这个图中我们可以很容易地看出，在深夜租用自行车的数量是最低的。然后有增加，可能随着人们醒来并去工作。我们在 10 小时左右出现第一个高峰，然后趋于平稳，或者可能略有下降，然后在 18 小时左右人们通勤回家时出现第二个高峰，之后稳步下降。</p>
<div class="figure align-default" id="fig-bikes-data2">
<a class="reference internal image-reference" href="../_images/bikes_spline_data.png"><img alt="../_images/bikes_spline_data.png" src="../_images/bikes_spline_data.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 93 </span><span class="caption-text">使用样条拟合的自行车数据（黑点）。阴影曲线代表 <span class="math notranslate nohighlight">\(94\%\)</span> HDI 区间（均值），蓝色曲线代表平均趋势。</span><a class="headerlink" href="#fig-bikes-data2" title="Permalink to this image">¶</a></p>
</div>
<p>在这个自行车租赁示例中，我们正在处理一个循环变量，这意味着 0 小时等于 24 小时。这对我们来说可能或多或少是显而易见的，但对于我们的模型来说绝对不明显。 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 提供了一个简单的解决方案来告诉我们的模型变量是循环的。我们可以使用 cc 来代替使用 <code class="docutils literal notranslate"><span class="pre">bs</span></code> 定义设计矩阵，这是一个<em>圆形感知</em>的三次样条。我们建议你查看 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 文档以获取更多详细信息，并探索在以前的模型中使用 <code class="docutils literal notranslate"><span class="pre">cc</span></code> 并比较结果。</p>
</div>
<div class="section" id="choosing-knots-and-prior-for-splines">
<span id="id18"></span><h2>5.6 选择样条的结点和先验<a class="headerlink" href="#choosing-knots-and-prior-for-splines" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id19">
<h3>5.6.1 样条结点的选择<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>在使用样条曲线时，我们必须做出的一项建模决策，是选择结点数量和结点位置。这可能有点令人担忧，因为结点数量和它们的间距不是很好确定。当面临这种情形时，可以尝试拟合多个模型，然后使用 LOO 等方法来帮助我们选择最佳模型。</p>
<p><a class="reference internal" href="#tab-loo-splines"><span class="std std-numref">Table 12</span></a> 显示了模型拟合的结果，如代码 <a class="reference internal" href="#splines"><span class="std std-ref">splines</span></a> 中定义的模型，具有 <span class="math notranslate nohighlight">\(3\)</span>、<span class="math notranslate nohighlight">\(6\)</span>、<span class="math notranslate nohighlight">\(9\)</span>、<span class="math notranslate nohighlight">\(12\)</span> 和 <span class="math notranslate nohighlight">\(18\)</span> 个等距结点，可以看到 LOO 选择了 <span class="math notranslate nohighlight">\(12\)</span> 个结点的样条曲线作为最佳模型。</p>
<p><a class="reference internal" href="#tab-loo-splines"><span class="std std-numref">Table 12</span></a> 中有一个有趣现象：模型 <code class="docutils literal notranslate"><span class="pre">m_12k</span></code>（秩最高的模型）的权重为 <span class="math notranslate nohighlight">\(0.88\)</span> ，模型 <code class="docutils literal notranslate"><span class="pre">m_3k</span></code>（秩最后的模型）的权重为 <span class="math notranslate nohighlight">\(0.12\)</span> 。而其余模型的权重几乎为 <span class="math notranslate nohighlight">\(0\)</span> 。如 <a class="reference internal" href="chp_02.html#model-averaging"><span class="std std-ref">2.6 模型平均</span></a> 节中解释的，默认情况下，权重是使用堆叠计算的。堆叠尝试在一个元模型中组合多个模型，以最小化该元模型和 <em>真实</em> 生成模型之间的散度。作为结果，即便模型 <code class="docutils literal notranslate"><span class="pre">m_6k</span></code>、 <code class="docutils literal notranslate"><span class="pre">m_9k</span></code> 和 <code class="docutils literal notranslate"><span class="pre">m_18k</span></code> 均具有更好的 <code class="docutils literal notranslate"><span class="pre">loo</span></code> 值，但一旦元模型中已经包含了模型 <code class="docutils literal notranslate"><span class="pre">m_12k</span></code>，则它们并没也添加太多新的信息；与之相对的，模型 <code class="docutils literal notranslate"><span class="pre">m_3k</span></code> 的秩最低，但它似乎可以为模型平均做出一些额外的贡献。</p>
<p><a class="reference internal" href="#fig-bikes-spline-loo-knots"><span class="std std-numref">Fig. 94</span></a> 显示了所有模型的平均拟合样条曲线。</p>
<table class="table" id="tab-loo-splines">
<caption><span class="caption-number">Table 12 </span><span class="caption-text">使用 LOO 对具有不同结点数的样条模型进行比较</span><a class="headerlink" href="#tab-loo-splines" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td></td>
<td><p><strong>rank</strong></p></td>
<td><p><strong>loo</strong></p></td>
<td><p><strong>p_loo</strong></p></td>
<td><p><strong>d_loo</strong></p></td>
<td><p><strong>weight</strong></p></td>
<td><p><strong>se</strong></p></td>
<td><p><strong>dse</strong></p></td>
<td><p><strong>warning</strong></p></td>
<td><p><strong>loo_scale</strong></p></td>
</tr>
<tr class="row-even"><td><p>m_12k</p></td>
<td><p>0</p></td>
<td><p>-377.67</p></td>
<td><p>14.21</p></td>
<td><p>0.00</p></td>
<td><p>0.88</p></td>
<td><p>17.86</p></td>
<td><p>0.00</p></td>
<td><p>False</p></td>
<td><p>log</p></td>
</tr>
<tr class="row-odd"><td><p>m_18k</p></td>
<td><p>1</p></td>
<td><p>-379.78</p></td>
<td><p>17.56</p></td>
<td><p>2.10</p></td>
<td><p>0.00</p></td>
<td><p>17.89</p></td>
<td><p>1.45</p></td>
<td><p>False</p></td>
<td><p>log</p></td>
</tr>
<tr class="row-even"><td><p>m_9k</p></td>
<td><p>2</p></td>
<td><p>-380.42</p></td>
<td><p>11.43</p></td>
<td><p>2.75</p></td>
<td><p>0.00</p></td>
<td><p>18.12</p></td>
<td><p>2.97</p></td>
<td><p>False</p></td>
<td><p>log</p></td>
</tr>
<tr class="row-odd"><td><p>m_6k</p></td>
<td><p>3</p></td>
<td><p>-389.43</p></td>
<td><p>9.41</p></td>
<td><p>11.76</p></td>
<td><p>0.00</p></td>
<td><p>18.16</p></td>
<td><p>5.72</p></td>
<td><p>False</p></td>
<td><p>log</p></td>
</tr>
<tr class="row-even"><td><p>m_3k</p></td>
<td><p>4</p></td>
<td><p>400.25</p></td>
<td><p>7.17</p></td>
<td><p>22.58</p></td>
<td><p>0.12</p></td>
<td><p>18.01</p></td>
<td><p>7.78</p></td>
<td><p>False</p></td>
<td><p>log</p></td>
</tr>
</tbody>
</table>
<div class="figure align-default" id="fig-bikes-spline-loo-knots">
<a class="reference internal image-reference" href="../_images/bikes_spline_loo_knots.png"><img alt="../_images/bikes_spline_loo_knots.png" src="../_images/bikes_spline_loo_knots.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 94 </span><span class="caption-text">代码 <a class="reference internal" href="#splines"><span class="std std-ref">splines</span></a> 中描述的，具有不同结点数 <span class="math notranslate nohighlight">\(\{3, 6, 9, 12, 18\}\)</span> 的模型平均后验样条。根据 LOO ，模型 “m_12k” 以蓝色突出显示为秩最高的模型。模型 <code class="docutils literal notranslate"><span class="pre">m_3k</span></code> 以黑色突出显示，而其余模型则显示为灰色，因为其权重几乎为零（参见 <a class="reference internal" href="#tab-loo-splines"><span class="std std-numref">Table 12</span></a>）。</span><a class="headerlink" href="#fig-bikes-spline-loo-knots" title="Permalink to this image">¶</a></p>
</div>
<p>确定结点位置的一种建议方法，是根据分位数设置结点而不是均匀设置。在代码 <a class="reference internal" href="#knot-list"><span class="std std-ref">knot_list</span></a> 中，可以使用 <code class="docutils literal notranslate"><span class="pre">knot_list</span> <span class="pre">=</span> <span class="pre">np.quantile(data.hour,</span> <span class="pre">np.linspace(0,</span> <span class="pre">1,</span> <span class="pre">num_knots))</span></code> 来定义分位数<code class="docutils literal notranslate"><span class="pre">knot_list</span></code>。这样的话，我们就能够在数据较多的地方设置更多结点，而在数据较少的地方放置更少结点。这为数据更丰富的部分提供了更灵活的近似。</p>
</div>
<div class="section" id="regularizing-prior-for-splines">
<span id="id20"></span><h3>5.6.2 样条的正则化先验<a class="headerlink" href="#regularizing-prior-for-splines" title="Permalink to this headline">¶</a></h3>
<p>设置过少的结点会导致欠拟合，而设置过多结点又可能会导致过拟合，因此我们希望能够使用具有 <em>恰当</em> 数量的结点，然后选择正则化先验。</p>
<p>从样条的定义和 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 可以看出，相邻 <span class="math notranslate nohighlight">\(\boldsymbol{\beta}\)</span> 系数之间越接近，得到的函数就越平滑。想象一下，如果你在 <code class="xref std std-numref docutils literal notranslate"><span class="pre">fig:splines_weighted</span></code> 中删除了设计矩阵的两个相邻列，实际上是将其系数设置为了 <span class="math notranslate nohighlight">\(0\)</span> ，导致拟合的 <em>平滑度</em> 降低，因为在预测变量中缺少足够信息来覆盖一些子区域。因此，通过选择 <span class="math notranslate nohighlight">\(\boldsymbol{\beta}\)</span> 系数的先验，可以实现更平滑的拟合回归线，其中一种方式是使 <span class="math notranslate nohighlight">\(\beta_{i+1}\)</span> 的值与 <span class="math notranslate nohighlight">\(\beta_{i}\)</span> 相关：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\begin{split}
\beta_i \sim&amp; \mathcal{N}(0, 1) \\
\tau\sim&amp; \mathcal{N}(0,1) \\
\beta \sim&amp; \mathcal{N}(\beta_{i-1}, \tau) 
\end{split}\end{aligned}\end{split}\]</div>
<p>使用 PyMC3，可以使用高斯随机游走分布来设置先验，以获得等效版本：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\begin{split}
\tau\sim&amp; \mathcal{N}(0, 1) \\
\beta \sim&amp; \mathcal{G}RW(\beta, \tau) 
\end{split}\end{aligned}\end{split}\]</div>
<p>要查看此先验的效果，我们可以再次对自行车数据集进行分析，但这次使用<code class="docutils literal notranslate"><span class="pre">num_knots</span> <span class="pre">=</span> <span class="pre">12</span></code> 。我们使用 <code class="docutils literal notranslate"><span class="pre">splines</span></code> 模型和以下模型重新拟合数据：</p>
<div class="literal-block-wrapper docutils container" id="splines-rw">
<div class="code-block-caption"><span class="caption-number">Listing 67 </span><span class="caption-text">splines_rw</span><a class="headerlink" href="#splines-rw" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">splines_rw</span><span class="p">:</span>
    <span class="n">τ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s2">"τ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">β</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">GaussianRandomWalk</span><span class="p">(</span><span class="s2">"β"</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">τ</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">μ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Deterministic</span><span class="p">(</span><span class="s2">"μ"</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">β</span><span class="p">))</span>
    <span class="n">σ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s2">"σ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"c"</span><span class="p">,</span> <span class="n">μ</span><span class="p">,</span> <span class="n">σ</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">"count_normalized"</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">trace_splines_rw</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>在 <a class="reference internal" href="#fig-bikes-spline-data-grw"><span class="std std-numref">Fig. 95</span></a> 中，可以看到模型 <code class="docutils literal notranslate"><span class="pre">splines_rw</span></code>（黑线）的均值函数比没有平滑先验的均值函数（灰色粗线）波动更小，尽管差异非常小。</p>
<div class="figure align-default" id="fig-bikes-spline-data-grw">
<a class="reference internal image-reference" href="../_images/bikes_spline_data_grw.png"><img alt="../_images/bikes_spline_data_grw.png" src="../_images/bikes_spline_data_grw.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 95 </span><span class="caption-text">使用高斯先验（黑色）和正则化高斯随机游走先验（蓝色）拟合的自行车数据。两种情况都使用了 <span class="math notranslate nohighlight">\(22\)</span> 个结点。黑线对应于从 <code class="docutils literal notranslate"><span class="pre">splines</span></code> 模型计算的均值函数。蓝线是模型 <code class="docutils literal notranslate"><span class="pre">splines_rw</span></code> 对应的均值函数。</span><a class="headerlink" href="#fig-bikes-spline-data-grw" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="co-2">
<span id="modeling-co2-uptake-with-splines"></span><h2>5.7 用样条对 <span class="math notranslate nohighlight">\(CO_2\)</span> 吸收量建模<a class="headerlink" href="#co-2" title="Permalink to this headline">¶</a></h2>
<p>作为样条曲线的最后一个例子，我们将使用来自实验研究的数据 <span id="id21">[<a class="reference internal" href="references.html#id120">50</a>, <a class="reference internal" href="references.html#id121">51</a>]</span>。该实验测量了 <span class="math notranslate nohighlight">\(12\)</span> 种不同植物在不同条件下的二氧化碳吸收量。这里我们主要探索 <span class="math notranslate nohighlight">\(CO_2\)</span> 的汇聚效应，即环境中的 <span class="math notranslate nohighlight">\(CO_2\)</span> 浓度对不同植物二氧化碳吸收能力的影响。实验为 <span class="math notranslate nohighlight">\(12\)</span> 类植物中的每一类分别在 <span class="math notranslate nohighlight">\(7\)</span> 个 <span class="math notranslate nohighlight">\(CO_2\)</span> 浓度下测量了 <span class="math notranslate nohighlight">\(CO_2\)</span> 吸收量。</p>
<p>让我们从加载和整理数据开始：</p>
<div class="literal-block-wrapper docutils container" id="plants-co2-import">
<div class="code-block-caption"><span class="caption-number">Listing 68 </span><span class="caption-text">plants_co2_import</span><a class="headerlink" href="#plants-co2-import" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plants_CO2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">"../data/CO2_uptake.csv"</span><span class="p">)</span>
<span class="n">plant_names</span> <span class="o">=</span> <span class="n">plants_CO2</span><span class="o">.</span><span class="n">Plant</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

<span class="c1"># Index the first 7 CO2 measurements per plant</span>
<span class="n">CO2_conc</span> <span class="o">=</span> <span class="n">plants_CO2</span><span class="o">.</span><span class="n">conc</span><span class="o">.</span><span class="n">values</span><span class="p">[:</span><span class="mi">7</span><span class="p">]</span>

<span class="c1"># Get full array which are the 7 measurements above repeated 12 times</span>
<span class="n">CO2_concs</span> <span class="o">=</span> <span class="n">plants_CO2</span><span class="o">.</span><span class="n">conc</span><span class="o">.</span><span class="n">values</span>
<span class="n">uptake</span> <span class="o">=</span> <span class="n">plants_CO2</span><span class="o">.</span><span class="n">uptake</span><span class="o">.</span><span class="n">values</span>

<span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>我们要拟合的第一个模型假设所有 <span class="math notranslate nohighlight">\(12\)</span> 类植物的结果曲线相同。首先使用 <code class="docutils literal notranslate"><span class="pre">Patsy</span></code> 定义设计矩阵，就像之前做的那样。由于每种植物仅有 <span class="math notranslate nohighlight">\(7\)</span> 个观测值，所以我们设置 <code class="docutils literal notranslate"><span class="pre">num_knots=2</span></code> 应该也可以正常工作。在代码 <a class="reference internal" href="#plants-co2-import"><span class="std std-ref">plants_co2_import</span></a> 中，<code class="docutils literal notranslate"><span class="pre">CO2_concs</span></code> 是一个二氧化碳浓度列表，其值 <code class="docutils literal notranslate"><span class="pre">[95,</span> <span class="pre">175,</span> <span class="pre">250,</span> <span class="pre">350,</span> <span class="pre">500,</span> <span class="pre">675,</span> <span class="pre">1000]</span></code> 共重复 <span class="math notranslate nohighlight">\(12\)</span> 次，每次分别对应一类植物。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_knots</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">knot_list</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html#numpy.linspace" title="numpy.linspace"><span class="n">np</span><span class="o">.</span><span class="n">linspace</span></a><span class="p">(</span><span class="n">CO2_conc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">CO2_conc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_knots</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">Bg</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span>
    <span class="s2">"bs(conc, knots=knots, degree=3, include_intercept=True) - 1"</span><span class="p">,</span>
    <span class="p">{</span><span class="s2">"conc"</span><span class="p">:</span> <span class="n">CO2_concs</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span> <span class="n">knot_list</span><span class="p">})</span>
</pre></div>
</div>
<p>这个问题看起来类似于前面章节中的自行车租赁问题，因此可以从相同的模型开始。</p>
<blockquote>
<div><p>使用我们已经在以前的问题中应用过的模型或我们从文献中学到的模型是开始分析的好方法。这种模型-模板方法可以被视为模型设计过程的捷径 <span id="id22">[<a class="reference internal" href="references.html#id78">17</a>]</span>。除了不必从头开始考虑模型的明显优势之外，我们还有其他优势，例如对如何执行模型的探索性分析有更好的直觉，然后可以对模型进行修改以简化它或使它更复杂。</p>
</div></blockquote>
<div class="literal-block-wrapper docutils container" id="sp-global">
<div class="code-block-caption"><span class="caption-number">Listing 69 </span><span class="caption-text">sp_global</span><a class="headerlink" href="#sp-global" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">sp_global</span><span class="p">:</span>
    <span class="n">τ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s2">"τ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">β</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"β"</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">τ</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">Bg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">μg</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Deterministic</span><span class="p">(</span><span class="s2">"μg"</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Bg</span><span class="p">,</span> <span class="n">β</span><span class="p">))</span>
    <span class="n">σ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s2">"σ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"up"</span><span class="p">,</span> <span class="n">μg</span><span class="p">,</span> <span class="n">σ</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">uptake</span><span class="p">)</span>
    <span class="n">idata_sp_global</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="n">return_inferencedata</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>从 <a class="reference internal" href="#fig-sp-global"><span class="std std-numref">Fig. 96</span></a> 中可以清楚地看到，该模型只为某些植物提供了良好的拟合。该模型平均而言是好的，但对于特定植物来说并不是太好。</p>
<div class="figure align-default" id="fig-sp-global">
<a class="reference internal image-reference" href="../_images/sp_global.png"><img alt="../_images/sp_global.png" src="../_images/sp_global.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 96 </span><span class="caption-text">黑点代表 <span class="math notranslate nohighlight">\(12\)</span> 种植物（Qn1、Qn2、Qn3、Qc1、Qc2、Qc3、Mn1、Mn2、Mn3、Mc1、Mc2、Mc3）在 <span class="math notranslate nohighlight">\(7\)</span> 个 <span class="math notranslate nohighlight">\(CO_2\)</span> 浓度下测量的 <span class="math notranslate nohighlight">\(CO_2\)</span> 吸收量。黑线是代码 <a class="reference internal" href="#sp-global"><span class="std std-ref">sp_global</span></a> 中模型的均值样条拟合，灰色阴影曲线表示该拟合的 <span class="math notranslate nohighlight">\(94\%\)</span> 高密度区间。</span><a class="headerlink" href="#fig-sp-global" title="Permalink to this image">¶</a></p>
</div>
<p>现在让我们尝试使用每种植物具有不同结果的模型，为此在代码 <a class="reference internal" href="#bi-matrix"><span class="std std-ref">Bi_matrix</span></a> 中定义了设计矩阵 <code class="docutils literal notranslate"><span class="pre">Bi</span></code> 。 <code class="docutils literal notranslate"><span class="pre">Bi</span></code> 使用列表 <code class="docutils literal notranslate"><span class="pre">CO2_conc</span> <span class="pre">=</span> <span class="pre">[95,</span> <span class="pre">175,</span> <span class="pre">250,</span> <span class="pre">350,</span> <span class="pre">500,</span> <span class="pre">675,</span> <span class="pre">1000]</span></code>，因此是一个 <span class="math notranslate nohighlight">\(7 \times 7\)</span> d的矩阵，而 <code class="docutils literal notranslate"><span class="pre">Bg</span></code> 是一个 <span class="math notranslate nohighlight">\(84 \times 7\)</span> 矩阵。</p>
<div class="literal-block-wrapper docutils container" id="bi-matrix">
<div class="code-block-caption"><span class="caption-number">Listing 70 </span><span class="caption-text">Bi_matrix</span><a class="headerlink" href="#bi-matrix" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Bi</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span>
    <span class="s2">"bs(conc, knots=knots, degree=3, include_intercept=True) - 1"</span><span class="p">,</span>
    <span class="p">{</span><span class="s2">"conc"</span><span class="p">:</span> <span class="n">CO2_conc</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span> <span class="n">knot_list</span><span class="p">})</span>
</pre></div>
</div>
</div>
<p>对应于 <code class="docutils literal notranslate"><span class="pre">Bi</span></code> 的形状，代码 <a class="reference internal" href="#sp-individual"><span class="std std-ref">sp_individual</span></a> 中的参数 <span class="math notranslate nohighlight">\(\beta\)</span> 具有形状 <code class="docutils literal notranslate"><span class="pre">shape=(Bi.shape[1],</span> <span class="pre">groups))</span></code>（ 不是 <code class="docutils literal notranslate"><span class="pre">shape=(Bg</span> <span class="pre">.shape[1]))</span></code>) ，并且做整形操作 <code class="docutils literal notranslate"><span class="pre">μi[:,index].T.ravel()</span></code>。</p>
<div class="literal-block-wrapper docutils container" id="sp-individual">
<div class="code-block-caption"><span class="caption-number">Listing 71 </span><span class="caption-text">sp_individual</span><a class="headerlink" href="#sp-individual" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">sp_individual</span><span class="p">:</span>
    <span class="n">τ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s2">"τ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">β</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"β"</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">τ</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Bi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">groups</span><span class="p">))</span>
    <span class="n">μi</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Deterministic</span><span class="p">(</span><span class="s2">"μi"</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Bi</span><span class="p">,</span> <span class="n">β</span><span class="p">))</span>
    <span class="n">σ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s2">"σ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"up"</span><span class="p">,</span> <span class="n">μi</span><span class="p">[:,</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">σ</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">uptake</span><span class="p">)</span>
    <span class="n">idata_sp_individual</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="n">return_inferencedata</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>从 <a class="reference internal" href="#fig-sp-individual"><span class="std std-numref">Fig. 97</span></a> 中可以看到，我们对 <span class="math notranslate nohighlight">\(12\)</span> 种植物中的每一种都有了更好的拟合。</p>
<div class="figure align-default" id="fig-sp-individual">
<a class="reference internal image-reference" href="../_images/sp_individual.png"><img alt="../_images/sp_individual.png" src="../_images/sp_individual.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 97 </span><span class="caption-text">在 <span class="math notranslate nohighlight">\(12\)</span> 种植物的 <span class="math notranslate nohighlight">\(7\)</span> 个 <span class="math notranslate nohighlight">\(CO_2\)</span> 浓度下测量的 <span class="math notranslate nohighlight">\(CO_2\)</span> 吸收量。黑线是代码 <a class="reference internal" href="#sp-individual"><span class="std std-ref">sp_individual</span></a> 中模型的均值样条拟合，灰色阴影曲线表示该拟合的 <span class="math notranslate nohighlight">\(94\%\)</span> 高密度区间。</span><a class="headerlink" href="#fig-sp-individual" title="Permalink to this image">¶</a></p>
</div>
<p>我们还可以混合前面两种模型 <a class="footnote-reference brackets" href="#id36" id="id23">13</a>。当我们想估计 <span class="math notranslate nohighlight">\(12\)</span> 种植物的整体趋势和各自的拟合时，这会非常有趣。代码 <a class="reference internal" href="#sp-mix"><span class="std std-ref">sp_mix</span></a> 中的模型 <code class="docutils literal notranslate"><span class="pre">sp_mix</span></code> 使用了先前定义的设计矩阵 <code class="docutils literal notranslate"><span class="pre">Bg</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Bi</span></code>。</p>
<div class="literal-block-wrapper docutils container" id="sp-mix">
<div class="code-block-caption"><span class="caption-number">Listing 72 </span><span class="caption-text">sp_mix</span><a class="headerlink" href="#sp-mix" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">sp_mix</span><span class="p">:</span>
    <span class="n">τ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s2">"τ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">βg</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"βg"</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">τ</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">Bg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">μg</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Deterministic</span><span class="p">(</span><span class="s2">"μg"</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Bg</span><span class="p">,</span> <span class="n">βg</span><span class="p">))</span>
    <span class="n">βi</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"βi"</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">τ</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Bi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">groups</span><span class="p">))</span>
    <span class="n">μi</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Deterministic</span><span class="p">(</span><span class="s2">"μi"</span><span class="p">,</span> <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Bi</span><span class="p">,</span> <span class="n">βi</span><span class="p">))</span>
    <span class="n">σ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s2">"σ"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s2">"up"</span><span class="p">,</span> <span class="n">μg</span><span class="o">+</span><span class="n">μi</span><span class="p">[:,</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">σ</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">uptake</span><span class="p">)</span>
    <span class="n">idata_sp_mix</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="n">return_inferencedata</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#fig-sp-mix-decomposed"><span class="std std-numref">Fig. 98</span></a> 显示了模型 <code class="docutils literal notranslate"><span class="pre">sp_mix</span></code> 的拟合结果。该模型的一个优点是可以将各种植物的拟合（蓝色）分解为两项，一项是全局趋势，表示为黑色，另一项是每种植物的偏差趋势，表示为灰色。注意黑色的全局趋势在每个子图中是重复的。偏差不仅在平均吸收量上有所不同（即它们不是扁平的直线），而且它们的函数相应形状也在不同程度上存在区别。</p>
<div class="figure align-default" id="fig-sp-mix-decomposed">
<a class="reference internal image-reference" href="../_images/sp_mix_decomposed.png"><img alt="../_images/sp_mix_decomposed.png" src="../_images/sp_mix_decomposed.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 98 </span><span class="caption-text">在 <span class="math notranslate nohighlight">\(12\)</span> 种植物的 <span class="math notranslate nohighlight">\(7\)</span> 种 <span class="math notranslate nohighlight">\(CO_2\)</span> 浓度下测量的 <span class="math notranslate nohighlight">\(CO_2\)</span> 吸收量。蓝线是代码 <a class="reference internal" href="#sp-mix"><span class="std std-ref">sp_mix</span></a> 中模型的均值样条拟合，灰色阴影曲线表示该拟合的 <span class="math notranslate nohighlight">\(94\%\)</span> HDI 区间。这种拟合被分解为两项。黑色和深灰色带表示全局贡献，灰色和浅灰色带表示与全局贡献的偏差。蓝线和蓝带是全局趋势及其偏差的总和。</span><a class="headerlink" href="#fig-sp-mix-decomposed" title="Permalink to this image">¶</a></p>
</div>
<p><a class="reference internal" href="#fig-sp-compare"><span class="std std-numref">Fig. 99</span></a> 表明根据 LOO <code class="docutils literal notranslate"><span class="pre">sp_mix</span></code> 是比其他两个更好的模型。我们可以看到，由于<code class="docutils literal notranslate"><span class="pre">sp_mix</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sp_individual</span></code> 模型的标准误差部分重叠，因此该指定仍然存在一些不确定性。我们还可以看到，模型 <code class="docutils literal notranslate"><span class="pre">sp_mix</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sp_individual</span></code> 比 <code class="docutils literal notranslate"><span class="pre">sp_global</span></code> 受到更严重的惩罚（ <code class="docutils literal notranslate"><span class="pre">sp_global</span></code> 的空圆圈和黑色圆圈之间的距离更短）。我们注意到 LOO 计算返回关于帕累托分布的估计形状参数大于 <span class="math notranslate nohighlight">\(0.7\)</span> 的警告。对于此示例，我们将在此停止，但为了进行真正的分析，应该进一步注意这些警告，并尝试遵循第 <a class="reference internal" href="chp_02.html#k-paretto"><span class="std std-ref">2.5.4 帕累托形状参数 \hat \kappa</span></a> 部分中描述的一些操作。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cmp</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://arviz-devs.github.io/arviz/api/generated/arviz.compare.html#arviz.compare" title="arviz.compare"><span class="n">az</span><span class="o">.</span><span class="n">compare</span></a><span class="p">({</span><span class="s2">"global"</span><span class="p">:</span><span class="n">idata_sp_global</span><span class="p">,</span> 
                  <span class="s2">"individual"</span><span class="p">:</span><span class="n">idata_sp_individual</span><span class="p">,</span> 
                  <span class="s2">"mix"</span><span class="p">:</span><span class="n">idata_sp_mix</span><span class="p">})</span>
</pre></div>
</div>
<div class="figure align-default" id="fig-sp-compare">
<a class="reference internal image-reference" href="../_images/sp_compare.png"><img alt="../_images/sp_compare.png" src="../_images/sp_compare.png" style="width: 8.00in;"/></a>
<p class="caption"><span class="caption-number">Fig. 99 </span><span class="caption-text">使用 LOO 对本章讨论的 <span class="math notranslate nohighlight">\(3\)</span> 种不同 <span class="math notranslate nohighlight">\(CO_2\)</span> 吸收模型（<code class="docutils literal notranslate"><span class="pre">sp_global</span></code>、<code class="docutils literal notranslate"><span class="pre">sp_individual</span></code>、<code class="docutils literal notranslate"><span class="pre">sp_mix</span></code>）进行模型比较。模型的预测准确度从高到低排列。空心点代表 LOO 的值，黑点是样本内预测精度。黑色部分代表 LOO 计算的标准误差。以三角形为中心的灰色部分表示每个模型的 LOO 值与秩最佳的模型之间的差值的标准误差。</span><a class="headerlink" href="#fig-sp-compare" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="exercises5">
<span id="id24"></span><h2>5.8 练习<a class="headerlink" href="#exercises5" title="Permalink to this headline">¶</a></h2>
<p><strong>5E1.</strong>. Splines are quite powerful so its good to know when and where to use them. To reinforce this explain each of the following</p>
<ol class="simple">
<li><p>The differences between linear regression and splines.</p></li>
<li><p>When you may want to use linear regression over splines</p></li>
<li><p>Why splines is usually preferred over polynomial regression of high     order.</p></li>
</ol>
<p><strong>5E2.</strong> Redo <a class="reference internal" href="#fig-polynomial-regression"><span class="std std-numref">Fig. 87</span></a> but fitting a polynomial of degree 0 and of degree 1. Does they look similar to any other type of model. Hint: you may want to use the code in the GitHub repository.</p>
<p><strong>5E3.</strong> Redo <a class="reference internal" href="#fig-piecewise"><span class="std std-numref">Fig. 88</span></a> but changing the value of one or the two knots. How the position of the knots affects the fit? You will find the code in the GitHub repository.</p>
<p><strong>5E4.</strong> Below we provide some data. To each data fit a 0, 1, and 3 degree spline. Plot the fit, including the data and position of the knots. Use <code class="docutils literal notranslate"><span class="pre">knots</span> <span class="pre">=</span> <span class="pre">np.linspace(-0.8,</span> <span class="pre">0.8,</span> <span class="pre">4)</span></code>. Describe the fit.</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">np.linspace(-1,</span> <span class="pre">1.,</span> <span class="pre">200)</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">np.random.normal(2*x,</span> <span class="pre">0.25)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">np.linspace(-1,</span> <span class="pre">1.,</span> <span class="pre">200)</span></code> and     <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">np.random.normal(x**2,</span> <span class="pre">0.25)</span></code></p></li>
<li><p>pick a function you like.</p></li>
</ol>
<p><strong>5E5.</strong> In Code Block <a class="reference internal" href="#bikes-dmatrix"><span class="std std-ref">bikes_dmatrix</span></a> we used a non-cyclic aware design matrix. Plot this design matrix. Then generate a cyclic design matrix. Plot this one too what is the difference?</p>
<p><strong>5E6.</strong> Generate the following design matrices using Patsy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <a class="sphinx-codeautolink-a" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html#numpy.linspace" title="numpy.linspace"><span class="n">np</span><span class="o">.</span><span class="n">linspace</span></a><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">knots</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]</span>

<span class="n">B0</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="s2">"bs(x, knots=knots, degree=3, include_intercept=False) +1"</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span><span class="n">knots</span><span class="p">})</span>
<span class="n">B1</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="s2">"bs(x, knots=knots, degree=3, include_intercept=True) +1"</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span><span class="n">knots</span><span class="p">})</span>
<span class="n">B2</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="s2">"bs(x, knots=knots, degree=3, include_intercept=False) -1"</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span><span class="n">knots</span><span class="p">})</span>
<span class="n">B3</span> <span class="o">=</span> <span class="n">dmatrix</span><span class="p">(</span><span class="s2">"bs(x, knots=knots, degree=3, include_intercept=True) -1"</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">"knots"</span><span class="p">:</span><span class="n">knots</span><span class="p">})</span>
</pre></div>
</div>
<ol class="simple">
<li><p>What is the shape of each one of the matrices? Can you justify the   values for the shapes?</p></li>
<li><p>Could you explain what the arguments <code class="docutils literal notranslate"><span class="pre">include_intercept=True/False</span></code>   and the <code class="docutils literal notranslate"><span class="pre">+1/-1</span></code> do? Try generating figures like   <a class="reference internal" href="#fig-splines-basis"><span class="std std-numref">Fig. 89</span></a> and <a class="reference internal" href="#fig-design-matrices"><span class="std std-numref">Fig. 90</span></a> to   help you answer this question</p></li>
</ol>
<p><strong>5E7.</strong> Refit the bike rental example using the options listed below. Visually compare the results and try to explain the results:</p>
<ol class="simple">
<li><p>Code Block <a class="reference internal" href="#knot-list"><span class="std std-ref">knot_list</span></a> but do not remove   the first and last knots (i.e. without using 1:-1)</p></li>
<li><p>Use quantiles to set the knots instead of spacing them linearly.</p></li>
<li><p>Repeat the previous two points but with less knots</p></li>
</ol>
<p><strong>5E8.</strong> In the GitHub repository you will find the spectra dataset use it to:</p>
<ol class="simple">
<li><p>Fit a cubic spline with knots   <code class="docutils literal notranslate"><span class="pre">np.quantile(X,</span> <span class="pre">np.arange(0.1,</span> <span class="pre">1,</span> <span class="pre">0.02))</span></code> and a Gaussian prior (like   in Code Block <a class="reference internal" href="#splines"><span class="std std-ref">splines</span></a>)</p></li>
<li><p>Fit a cubic spline with knots   <code class="docutils literal notranslate"><span class="pre">np.quantile(X,</span> <span class="pre">np.arange(0.1,</span> <span class="pre">1,</span> <span class="pre">0.02))</span></code> and a Gaussian Random Walk   prior (like in Code Block <a class="reference internal" href="#splines-rw"><span class="std std-ref">splines_rw</span></a>)</p></li>
<li><p>Fit a cubic spline with knots   <code class="docutils literal notranslate"><span class="pre">np.quantile(X,</span> <span class="pre">np.arange(0.1,</span> <span class="pre">1,</span> <span class="pre">0.1))</span></code> and a Gaussian prior (like   in Code Block <a class="reference internal" href="#splines"><span class="std std-ref">splines</span></a>)</p></li>
<li><p>compare the fits visually and using LOO</p></li>
</ol>
<p><strong>5M9.</strong> Redo <a class="reference internal" href="#fig-piecewise"><span class="std std-numref">Fig. 88</span></a> extending <code class="docutils literal notranslate"><span class="pre">x_max</span></code> from 6 to 12.</p>
<ol class="simple">
<li><p>How this change affects the fit?</p></li>
<li><p>What are the implications for extrapolation?</p></li>
<li><p>add one more knot and make the necessary changes in the code so the   fit actually use the 3 knots.</p></li>
<li><p>change the position of the third new knot to improve the fit as much   as possible.</p></li>
</ol>
<p><strong>5M10.</strong> For the bike rental example increase the number of knots. What is the effect on the fit? Change the width of the prior and visually evaluate the effect on the fit. What do you think the combination of knot number and prior weights controls?</p>
<p><strong>5M11.</strong> Fit the baby regression example from Chapter <a class="reference internal" href="chp_04.html#chap3"><span class="std std-ref">4</span></a> using splines.</p>
<p><strong>5M12.</strong> In Code Block <a class="reference internal" href="#bikes-dmatrix"><span class="std std-ref">bikes_dmatrix</span></a> we used a non-circular aware design matrix. Since we describe the hours in a day as cyclic, we want to use cyclic splines. However, there is one wrinkle. In the original dataset the hours range from 0 to 23, so using a circular spline patsy would treat 0 and 23 are the same. Still, we want a circular spline regression so perform the following steps.</p>
<ol class="simple">
<li><p>Duplicate the 0 hour data label it as 24.</p></li>
<li><p>Generate a circular design matrix and a non-circular design matrix   with this modified dataset. Plot the results and compare.</p></li>
<li><p>Refit the bike spline dataset.</p></li>
<li><p>Explain what the effect of the circular spine regression was using   plots, numerical summaries, and diagnostics.</p></li>
</ol>
<p><strong>5M13.</strong> For the rent bike example we use a Gaussian as likelihood, this can be seen as a reasonable approximation when the number of counts is large, but still brings some problems, like predicting negative number of rented bikes (for example, at night when the observed number of rented bikes is close to zero). To fix this issue and improve our models we can try with other likelihoods:</p>
<ol class="simple">
<li><p>use a Poisson likelihood (hint you may need to restrict the <span class="math notranslate nohighlight">\(\beta\)</span>   coefficients to be positive, and you can not normalize the data as   we did in the example). How the fit differs from the example in the   book. is this a better fit? In what sense?</p></li>
<li><p>use a NegativeBinomial likelihood, how the fit differs from the   previous two? Could you explain the differences (hint, the   NegativeBinomial can be considered as a mixture model of Poisson   distributions, which often helps to model overdispersed data)</p></li>
<li><p>Use LOO to compare the spline model with Poisson and   NegativeBinomial likelihoods. Which one has the best predictive   performance?</p></li>
<li><p>Can you justify the values of <code class="docutils literal notranslate"><span class="pre">p_loo</span></code> and the values of   <span class="math notranslate nohighlight">\(\hat \kappa\)</span>?</p></li>
<li><p>Use LOO-PIT to compare Gaussian, NegativeBinomial and Poisson models</p></li>
</ol>
<p><strong>5M14.</strong> Using the model in Code Block <a class="reference internal" href="#splines"><span class="std std-ref">splines</span></a> as a guide and for <span class="math notranslate nohighlight">\(X \in [0, 1]\)</span>, set <span class="math notranslate nohighlight">\(\tau \sim \text{Laplace}(0, 1)\)</span>:</p>
<ol class="simple">
<li><p>Sample and plot realizations from the prior for <span class="math notranslate nohighlight">\(\mu\)</span>. Use different   number and locations for the knots</p></li>
<li><p>What is the prior expectation for <span class="math notranslate nohighlight">\(\mu(x_i)\)</span> and how does it depend   on the knots and X?</p></li>
<li><p>What is the prior expectation for the standard deviations of   <span class="math notranslate nohighlight">\(\mu(x_i)\)</span> and how does it depend on the knots and X?</p></li>
<li><p>Repeat the previous points for the prior predictive distribution</p></li>
<li><p>Repeat the previous points using a <span class="math notranslate nohighlight">\(\mathcal{H}\text{C}(1)\)</span></p></li>
</ol>
<p><strong>5M15.</strong> Fit the following data. Notice that the response variable is binary so you will need to adjust the likelihood accordingly and use a link function.</p>
<ol class="simple">
<li><p>a logistic regression from a previous chapter. Visually compare the   results between both models.</p></li>
<li><p>Space Influenza is a disease which affects mostly young and old   people, but not middle-age folks. Fortunately, Space Influenza is   not a serious concern as it is completely made up. In this dataset   we have a record of people that got tested for Space Influenza and   whether they are sick (1) or healthy (0) and also their age. Could   you have solved this problem using logistic regression?</p></li>
</ol>
<p><strong>5M16.</strong> Besides “hour” the bike dataset has other covariates, like “temperature”. Fit a splines using both covariates. The simplest way to do this is by defining a separated spline/design matrix for each covariate. Fit a model with a NegativeBinomial likelihood.</p>
<ol class="simple">
<li><p>Run diagnostics to check the sampling is correct and modify the   model and or sample hyperparameters accordingly.</p></li>
<li><p>How the rented bikes depend on the hours of the day and how on the   temperature?</p></li>
<li><p>Generate a model with only the hour covariate to the one with the   “hour” and “temperature”. Compare both model using LOO, LOO-PIT and   posterior predictive checks.</p></li>
<li><p>Summarize all your findings</p></li>
</ol>
<hr class="docutils"/>
<hr class="footnotes docutils"/>
<dl class="footnote brackets">
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>See Runge’s phenomenon for details. This can also be seen from   Taylor’s theorem, polynomials will be useful to approximate a   function close to a single given point, but it will not be good over   its whole domain. If you got lost try watching this video   <a class="reference external" href="https://www.youtube.com/watch?v=3d6DsjIBzJ4">https://www.youtube.com/watch?v=3d6DsjIBzJ4</a>.</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id5">2</a></span></dt>
<dd><p>A piecewise function is a function that is defined using   sub-functions, where each sub-function applies to a different   interval in the domain.</p>
</dd>
<dt class="label" id="id27"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>This can also be justified numerically as this reduces the number   of coefficients we need to find to compute a solution.</p>
</dd>
<dt class="label" id="id28"><span class="brackets"><a class="fn-backref" href="#id7">5</a></span></dt>
<dd><p>As usual the identity function is a valid choice.</p>
</dd>
<dt class="label" id="id29"><span class="brackets"><a class="fn-backref" href="#id9">6</a></span></dt>
<dd><p>Other basis functions could be wavelets or Fourier series as we   will see in Chapter <a class="reference internal" href="chp_06.html#chap4"><span class="std std-ref">6</span></a>.</p>
</dd>
<dt class="label" id="id30"><span class="brackets"><a class="fn-backref" href="#id11">7</a></span></dt>
<dd><p>Also known as break points, which is arguably a more memorable   name, but still knots is widely used in the literature.</p>
</dd>
<dt class="label" id="id31"><span class="brackets"><a class="fn-backref" href="#id13">8</a></span></dt>
<dd><p>In the limit of infinite degree a B-spline will span the entire   real line and not only that, it will converge to a Gaussian   <a class="reference external" href="https://www.youtube.com/watch/9CS7j5I6aOc">https://www.youtube.com/watch/9CS7j5I6aOc</a>.</p>
</dd>
<dt class="label" id="id32"><span class="brackets"><a class="fn-backref" href="#id14">9</a></span></dt>
<dd><p>Check   <a class="reference external" href="https://pclambert.net/interactivegraphs/spline_continuity/spline_continuity">https://pclambert.net/interactivegraphs/spline_continuity/spline_continuity</a>   for further intuition</p>
</dd>
<dt class="label" id="id33"><span class="brackets"><a class="fn-backref" href="#id15">10</a></span></dt>
<dd><p>If interested you can check   <a class="reference external" href="https://en.wikipedia.org/wiki/De_Boor%27s_algorithm">https://en.wikipedia.org/wiki/De_Boor%27s_algorithm</a>.</p>
</dd>
<dt class="label" id="id34"><span class="brackets"><a class="fn-backref" href="#id16">11</a></span></dt>
<dd><p><a class="reference external" href="https://patsy.readthedocs.io">https://patsy.readthedocs.io</a></p>
</dd>
<dt class="label" id="id35"><span class="brackets"><a class="fn-backref" href="#id17">12</a></span></dt>
<dd><p><a class="reference external" href="https://archive.ics.uci.edu/ml/datasets/bike+sharing+dataset">https://archive.ics.uci.edu/ml/datasets/bike+sharing+dataset</a></p>
</dd>
<dt class="label" id="id36"><span class="brackets"><a class="fn-backref" href="#id23">13</a></span></dt>
<dd><p>Yes, this is also known as a mixed-effect model, you might recall   the related concept we discussed in Chapter <a class="reference internal" href="chp_04.html#chap3"><span class="std std-ref">4</span></a>.</p>
</dd>
</dl>
</div>
</div>
<script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./zh_CN"
        },
        predefinedOutput: true
    }
    </script>
<script>kernelName = 'python3'</script>
</div>
<!-- Previous / next buttons -->
<div class="prev-next-area">
<a class="left-prev" href="chp_04.html" id="prev-link" title="previous page">
<i class="fas fa-angle-left"></i>
<div class="prev-next-info">
<p class="prev-next-subtitle">previous</p>
<p class="prev-next-title">第四章：扩展线性模型</p>
</div>
</a>
<a class="right-next" href="chp_06.html" id="next-link" title="next page">
<div class="prev-next-info">
<p class="prev-next-subtitle">next</p>
<p class="prev-next-title">第六章: 时间序列</p>
</div>
<i class="fas fa-angle-right"></i>
</a>
</div>
</div>
</div>
<footer class="footer">
<p>
    
      By Martin, Kumar, Lao<br/>
    
        © Copyright 2021.<br/>
</p>
</footer>
</main>
</div>
</div>
<script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
</body>
</html>